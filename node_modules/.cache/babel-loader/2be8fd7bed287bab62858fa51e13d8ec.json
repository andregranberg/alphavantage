{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { getRequestKey, fetchDedupe, isRequestInFlight } from 'fetch-dedupe'; // This object is our cache\n// The keys of the object are requestKeys\n// The value of each key is a Response instance\n\nvar responseCache = {}; // The docs state that this is not safe to use in an\n// application. That's just because I am not writing tests,\n// nor designing the API, around folks clearing the cache.\n// This was only added to help out with testing your app.\n// Use your judgment if you decide to use this in your\n// app directly.\n\nexport function clearResponseCache() {\n  responseCache = {};\n}\nexport var Fetch = function (_React$Component) {\n  _inherits(Fetch, _React$Component);\n\n  _createClass(Fetch, [{\n    key: 'render',\n    value: function render() {\n      // Anything pulled from `this.props` here is not eligible to be\n      // specified when calling `doFetch`.\n      var _props = this.props,\n          children = _props.children,\n          requestName = _props.requestName;\n      var _state = this.state,\n          fetching = _state.fetching,\n          response = _state.response,\n          data = _state.data,\n          error = _state.error,\n          requestKey = _state.requestKey,\n          url = _state.url;\n\n      if (!children) {\n        return null;\n      } else {\n        return children({\n          requestName: requestName,\n          url: url,\n          fetching: fetching,\n          failed: Boolean(error || response && !response.ok),\n          response: response,\n          data: data,\n          requestKey: requestKey,\n          error: error,\n          doFetch: this.fetchRenderProp\n        }) || null;\n      }\n    }\n  }]);\n\n  function Fetch(props, context) {\n    _classCallCheck(this, Fetch);\n\n    var _this = _possibleConstructorReturn(this, (Fetch.__proto__ || Object.getPrototypeOf(Fetch)).call(this, props, context));\n\n    _this.isReadRequest = function (method) {\n      var uppercaseMethod = method.toUpperCase();\n      return uppercaseMethod === 'GET' || uppercaseMethod === 'HEAD' || uppercaseMethod === 'OPTIONS';\n    };\n\n    _this.isLazy = function () {\n      var _this$props = _this.props,\n          lazy = _this$props.lazy,\n          method = _this$props.method;\n      return typeof lazy === 'undefined' ? !_this.isReadRequest(method) : lazy;\n    };\n\n    _this.shouldCacheResponse = function () {\n      var _this$props2 = _this.props,\n          cacheResponse = _this$props2.cacheResponse,\n          method = _this$props2.method;\n      return typeof cacheResponse === 'undefined' ? _this.isReadRequest(method) : cacheResponse;\n    };\n\n    _this.getFetchPolicy = function () {\n      var _this$props3 = _this.props,\n          fetchPolicy = _this$props3.fetchPolicy,\n          method = _this$props3.method;\n\n      if (typeof fetchPolicy === 'undefined') {\n        return _this.isReadRequest(method) ? 'cache-first' : 'network-only';\n      } else {\n        return fetchPolicy;\n      }\n    };\n\n    _this.cancelExistingRequest = function (reason) {\n      if (_this.state.fetching && _this._currentRequestKey !== null) {\n        var abortError = new Error(reason); // This is an effort to mimic the error that is created when a\n        // fetch is actually aborted using the AbortController API.\n\n        abortError.name = 'AbortError';\n\n        _this.onResponseReceived(_extends({}, _this.responseReceivedInfo, {\n          error: abortError,\n          hittingNetwork: true\n        }));\n      }\n    };\n\n    _this.fetchRenderProp = function (options) {\n      return new Promise(function (resolve) {\n        // We wrap this in a setTimeout so as to avoid calls to `setState`\n        // in render, which React does not allow.\n        //\n        // tl;dr, the following code should never cause a React warning or error:\n        //\n        // `<Fetch children={({ doFetch }) => doFetch()} />\n        setTimeout(function () {\n          _this.fetchData(options, true, resolve);\n        });\n      });\n    };\n\n    _this.getRequestKey = function (options) {\n      // A request key in the options gets top priority\n      if (options && options.requestKey) {\n        return options.requestKey;\n      } // Otherwise, if we have no request key, but we do have options, then we\n      // recompute the request key based on these options.\n      // Note that if the URL, body, or method have not changed, then the request\n      // key should match the previous request key if it was computed.\n      // If you passed in a custom request key as a prop, then you will also\n      // need to pass in a custom key when you call `doFetch()`!\n      else if (options) {\n          var _Object$assign = Object.assign({}, _this.props, options),\n              url = _Object$assign.url,\n              method = _Object$assign.method,\n              body = _Object$assign.body;\n\n          return getRequestKey({\n            url: url,\n            body: body,\n            method: method.toUpperCase()\n          });\n        } // Next in line is the the request key from props.\n        else if (_this.props.requestKey) {\n            return _this.props.requestKey;\n          } // Lastly, we compute the request key from the props.\n          else {\n              var _this$props4 = _this.props,\n                  _url = _this$props4.url,\n                  _method = _this$props4.method,\n                  _body = _this$props4.body;\n              return getRequestKey({\n                url: _url,\n                body: _body,\n                method: _method.toUpperCase()\n              });\n            }\n    };\n\n    _this.fetchData = function (options, ignoreCache, resolve) {\n      // These are the things that we do not allow a user to configure in\n      // `options` when calling `doFetch()`. Perhaps we should, however.\n      var _this$props5 = _this.props,\n          requestName = _this$props5.requestName,\n          dedupe = _this$props5.dedupe,\n          beforeFetch = _this$props5.beforeFetch;\n\n      _this.cancelExistingRequest('New fetch initiated');\n\n      var requestKey = _this.getRequestKey(options);\n\n      var requestOptions = Object.assign({}, _this.props, options);\n      _this._currentRequestKey = requestKey;\n      var url = requestOptions.url,\n          body = requestOptions.body,\n          credentials = requestOptions.credentials,\n          headers = requestOptions.headers,\n          method = requestOptions.method,\n          responseType = requestOptions.responseType,\n          mode = requestOptions.mode,\n          cache = requestOptions.cache,\n          redirect = requestOptions.redirect,\n          referrer = requestOptions.referrer,\n          referrerPolicy = requestOptions.referrerPolicy,\n          integrity = requestOptions.integrity,\n          keepalive = requestOptions.keepalive,\n          signal = requestOptions.signal;\n      var uppercaseMethod = method.toUpperCase();\n\n      var shouldCacheResponse = _this.shouldCacheResponse();\n\n      var init = {\n        body: body,\n        credentials: credentials,\n        headers: headers,\n        method: uppercaseMethod,\n        mode: mode,\n        cache: cache,\n        redirect: redirect,\n        referrer: referrer,\n        referrerPolicy: referrerPolicy,\n        integrity: integrity,\n        keepalive: keepalive,\n        signal: signal\n      };\n      var responseReceivedInfo = {\n        url: url,\n        init: init,\n        requestKey: requestKey,\n        responseType: responseType\n      }; // This is necessary because `options` may have overridden the props.\n      // If the request config changes, we need to be able to accurately\n      // cancel the in-flight request.\n\n      _this.responseReceivedInfo = responseReceivedInfo;\n\n      var fetchPolicy = _this.getFetchPolicy();\n\n      var cachedResponse = void 0;\n\n      if (fetchPolicy !== 'network-only' && !ignoreCache) {\n        cachedResponse = responseCache[requestKey];\n\n        if (cachedResponse) {\n          _this.onResponseReceived(_extends({}, responseReceivedInfo, {\n            response: cachedResponse,\n            hittingNetwork: false,\n            stillFetching: fetchPolicy === 'cache-and-network'\n          }));\n\n          if (fetchPolicy === 'cache-first' || fetchPolicy === 'cache-only') {\n            return Promise.resolve(cachedResponse);\n          }\n        } else if (fetchPolicy === 'cache-only') {\n          var cacheError = new Error('Response for \"' + requestName + '\" not found in cache.');\n\n          _this.onResponseReceived(_extends({}, responseReceivedInfo, {\n            error: cacheError,\n            hittingNetwork: false\n          }));\n\n          return Promise.resolve(cacheError);\n        }\n      }\n\n      _this.setState({\n        requestKey: requestKey,\n        url: url,\n        error: null,\n        failed: false,\n        fetching: true\n      });\n\n      var hittingNetwork = !isRequestInFlight(requestKey) || !dedupe;\n\n      if (hittingNetwork) {\n        beforeFetch({\n          url: url,\n          init: init,\n          requestKey: requestKey\n        });\n      }\n\n      return fetchDedupe(url, init, {\n        requestKey: requestKey,\n        responseType: responseType,\n        dedupe: dedupe\n      }).then(function (res) {\n        if (shouldCacheResponse) {\n          responseCache[requestKey] = res;\n        }\n\n        if (_this._currentRequestKey === requestKey) {\n          _this.onResponseReceived(_extends({}, responseReceivedInfo, {\n            response: res,\n            hittingNetwork: hittingNetwork,\n            resolve: resolve\n          }));\n        }\n\n        return res;\n      }, function (error) {\n        if (_this._currentRequestKey === requestKey) {\n          _this.onResponseReceived(_extends({}, responseReceivedInfo, {\n            error: error,\n            cachedResponse: cachedResponse,\n            hittingNetwork: hittingNetwork,\n            resolve: resolve\n          }));\n        }\n\n        return error;\n      });\n    };\n\n    _this.onResponseReceived = function (info) {\n      var _info$error = info.error,\n          error = _info$error === undefined ? null : _info$error,\n          _info$response = info.response,\n          response = _info$response === undefined ? null : _info$response,\n          hittingNetwork = info.hittingNetwork,\n          url = info.url,\n          init = info.init,\n          requestKey = info.requestKey,\n          cachedResponse = info.cachedResponse,\n          _info$stillFetching = info.stillFetching,\n          stillFetching = _info$stillFetching === undefined ? false : _info$stillFetching,\n          resolve = info.resolve;\n      _this.responseReceivedInfo = null;\n\n      if (!stillFetching) {\n        _this._currentRequestKey = null;\n      }\n\n      var data = void 0; // If our response succeeded, then we use that data.\n\n      if (response && response.data) {\n        data = response.data;\n      } else if (cachedResponse && cachedResponse.data) {\n        // This happens when the request failed, but we have cache-and-network\n        // specified. Although we pass along the failed response, we continue to\n        // pass in the cached data.\n        data = cachedResponse.data;\n      }\n\n      data = data ? _this.props.transformData(data) : null; // If we already have some data in state on error, then we continue to\n      // pass that data down. This prevents the data from being wiped when a\n      // request fails, which is generally not what people want.\n      // For more, see: GitHub Issue #154\n\n      if (error && _this.state.data) {\n        data = _this.state.data;\n      }\n\n      var afterFetchInfo = {\n        url: url,\n        init: init,\n        requestKey: requestKey,\n        error: error,\n        failed: Boolean(error || response && !response.ok),\n        response: response,\n        data: data,\n        didUnmount: Boolean(_this.willUnmount)\n      };\n\n      if (typeof resolve === 'function') {\n        resolve(afterFetchInfo);\n      }\n\n      if (hittingNetwork) {\n        _this.props.afterFetch(afterFetchInfo);\n      }\n\n      if (_this.willUnmount) {\n        return;\n      }\n\n      _this.setState({\n        url: url,\n        data: data,\n        error: error,\n        response: response,\n        fetching: stillFetching,\n        requestKey: requestKey\n      }, function () {\n        return _this.props.onResponse(error, response);\n      });\n    };\n\n    _this.state = {\n      requestKey: props.requestKey || getRequestKey(_extends({}, props, {\n        method: props.method.toUpperCase()\n      })),\n      requestName: props.requestName,\n      fetching: false,\n      response: null,\n      data: null,\n      error: null,\n      url: props.url\n    };\n    return _this;\n  } // We default to being lazy for \"write\" requests,\n  // such as POST, PATCH, DELETE, and so on.\n\n\n  _createClass(Fetch, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      if (!this.isLazy()) {\n        this.fetchData();\n      }\n    } // Because we use `componentDidUpdate` to determine if we should fetch\n    // again, there will be at least one render when you receive your new\n    // fetch options, such as a new URL, but the fetch has not begun yet.\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps) {\n      var currentRequestKey = this.props.requestKey || getRequestKey(_extends({}, this.props, {\n        method: this.props.method.toUpperCase()\n      }));\n      var prevRequestKey = prevProps.requestKey || getRequestKey(_extends({}, prevProps, {\n        method: prevProps.method.toUpperCase()\n      }));\n\n      if (currentRequestKey !== prevRequestKey && !this.isLazy()) {\n        this.fetchData({\n          requestKey: currentRequestKey\n        });\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this.willUnmount = true;\n      this.cancelExistingRequest('Component unmounted');\n    } // When a request is already in flight, and a new one is\n    // configured, then we need to \"cancel\" the previous one.\n    // When a subsequent request is made, it is important that the correct\n    // request key is used. This method computes the right key based on the\n    // options and props.\n\n  }]);\n\n  return Fetch;\n}(React.Component);\nvar globalObj = typeof self !== 'undefined' ? self : this;\nvar AbortSignalCtr = globalObj !== undefined ? globalObj.AbortSignal : function () {};\nFetch.propTypes = {\n  children: PropTypes.func,\n  requestName: PropTypes.string,\n  fetchPolicy: PropTypes.oneOf(['cache-first', 'cache-and-network', 'network-only', 'cache-only']),\n  onResponse: PropTypes.func,\n  beforeFetch: PropTypes.func,\n  afterFetch: PropTypes.func,\n  responseType: PropTypes.oneOfType([PropTypes.func, PropTypes.oneOf(['json', 'text', 'blob', 'arrayBuffer', 'formData'])]),\n  transformData: PropTypes.func,\n  lazy: PropTypes.bool,\n  dedupe: PropTypes.bool,\n  requestKey: PropTypes.string,\n  url: PropTypes.string.isRequired,\n  body: PropTypes.any,\n  credentials: PropTypes.oneOf(['omit', 'same-origin', 'include']),\n  headers: PropTypes.object,\n  method: PropTypes.oneOf(['get', 'post', 'put', 'patch', 'delete', 'options', 'head', 'GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS', 'HEAD']),\n  mode: PropTypes.oneOf(['same-origin', 'cors', 'no-cors', 'navigate', 'websocket']),\n  cache: PropTypes.oneOf(['default', 'no-store', 'reload', 'no-cache', 'force-cache', 'only-if-cached']),\n  redirect: PropTypes.oneOf(['manual', 'follow', 'error']),\n  referrer: PropTypes.string,\n  referrerPolicy: PropTypes.oneOf(['no-referrer', 'no-referrer-when-downgrade', 'origin', 'origin-when-cross-origin', 'unsafe-url', '']),\n  integrity: PropTypes.string,\n  keepalive: PropTypes.bool,\n  signal: PropTypes.instanceOf(AbortSignalCtr)\n};\nFetch.defaultProps = {\n  requestName: 'anonymousRequest',\n  onResponse: function onResponse() {},\n  beforeFetch: function beforeFetch() {},\n  afterFetch: function afterFetch() {},\n  transformData: function transformData(data) {\n    return data;\n  },\n  dedupe: true,\n  method: 'get',\n  referrerPolicy: '',\n  integrity: '',\n  referrer: 'about:client'\n};","map":{"version":3,"sources":["/home/andrey/Documents/React/13.aqi/node_modules/react-request/es/fetch.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","defineProperty","Constructor","protoProps","staticProps","_classCallCheck","instance","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","value","setPrototypeOf","__proto__","React","PropTypes","getRequestKey","fetchDedupe","isRequestInFlight","responseCache","clearResponseCache","Fetch","_React$Component","render","_props","children","requestName","_state","state","fetching","response","data","error","requestKey","url","failed","Boolean","ok","doFetch","fetchRenderProp","context","_this","getPrototypeOf","isReadRequest","method","uppercaseMethod","toUpperCase","isLazy","_this$props","lazy","shouldCacheResponse","_this$props2","cacheResponse","getFetchPolicy","_this$props3","fetchPolicy","cancelExistingRequest","reason","_currentRequestKey","abortError","Error","name","onResponseReceived","responseReceivedInfo","hittingNetwork","options","Promise","resolve","setTimeout","fetchData","_Object$assign","body","_this$props4","_url","_method","_body","ignoreCache","_this$props5","dedupe","beforeFetch","requestOptions","credentials","headers","responseType","mode","cache","redirect","referrer","referrerPolicy","integrity","keepalive","signal","init","cachedResponse","stillFetching","cacheError","setState","then","res","info","_info$error","undefined","_info$response","_info$stillFetching","transformData","afterFetchInfo","didUnmount","willUnmount","afterFetch","onResponse","componentDidMount","componentDidUpdate","prevProps","currentRequestKey","prevRequestKey","componentWillUnmount","Component","globalObj","AbortSignalCtr","AbortSignal","propTypes","func","string","oneOf","oneOfType","bool","isRequired","any","object","instanceOf","defaultProps"],"mappings":"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","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { getRequestKey, fetchDedupe, isRequestInFlight } from 'fetch-dedupe';\n\n// This object is our cache\n// The keys of the object are requestKeys\n// The value of each key is a Response instance\nvar responseCache = {};\n\n// The docs state that this is not safe to use in an\n// application. That's just because I am not writing tests,\n// nor designing the API, around folks clearing the cache.\n// This was only added to help out with testing your app.\n// Use your judgment if you decide to use this in your\n// app directly.\nexport function clearResponseCache() {\n  responseCache = {};\n}\n\nexport var Fetch = function (_React$Component) {\n  _inherits(Fetch, _React$Component);\n\n  _createClass(Fetch, [{\n    key: 'render',\n    value: function render() {\n      // Anything pulled from `this.props` here is not eligible to be\n      // specified when calling `doFetch`.\n      var _props = this.props,\n          children = _props.children,\n          requestName = _props.requestName;\n      var _state = this.state,\n          fetching = _state.fetching,\n          response = _state.response,\n          data = _state.data,\n          error = _state.error,\n          requestKey = _state.requestKey,\n          url = _state.url;\n\n\n      if (!children) {\n        return null;\n      } else {\n        return children({\n          requestName: requestName,\n          url: url,\n          fetching: fetching,\n          failed: Boolean(error || response && !response.ok),\n          response: response,\n          data: data,\n          requestKey: requestKey,\n          error: error,\n          doFetch: this.fetchRenderProp\n        }) || null;\n      }\n    }\n  }]);\n\n  function Fetch(props, context) {\n    _classCallCheck(this, Fetch);\n\n    var _this = _possibleConstructorReturn(this, (Fetch.__proto__ || Object.getPrototypeOf(Fetch)).call(this, props, context));\n\n    _this.isReadRequest = function (method) {\n      var uppercaseMethod = method.toUpperCase();\n\n      return uppercaseMethod === 'GET' || uppercaseMethod === 'HEAD' || uppercaseMethod === 'OPTIONS';\n    };\n\n    _this.isLazy = function () {\n      var _this$props = _this.props,\n          lazy = _this$props.lazy,\n          method = _this$props.method;\n\n\n      return typeof lazy === 'undefined' ? !_this.isReadRequest(method) : lazy;\n    };\n\n    _this.shouldCacheResponse = function () {\n      var _this$props2 = _this.props,\n          cacheResponse = _this$props2.cacheResponse,\n          method = _this$props2.method;\n\n\n      return typeof cacheResponse === 'undefined' ? _this.isReadRequest(method) : cacheResponse;\n    };\n\n    _this.getFetchPolicy = function () {\n      var _this$props3 = _this.props,\n          fetchPolicy = _this$props3.fetchPolicy,\n          method = _this$props3.method;\n\n\n      if (typeof fetchPolicy === 'undefined') {\n        return _this.isReadRequest(method) ? 'cache-first' : 'network-only';\n      } else {\n        return fetchPolicy;\n      }\n    };\n\n    _this.cancelExistingRequest = function (reason) {\n      if (_this.state.fetching && _this._currentRequestKey !== null) {\n        var abortError = new Error(reason);\n        // This is an effort to mimic the error that is created when a\n        // fetch is actually aborted using the AbortController API.\n        abortError.name = 'AbortError';\n        _this.onResponseReceived(_extends({}, _this.responseReceivedInfo, {\n          error: abortError,\n          hittingNetwork: true\n        }));\n      }\n    };\n\n    _this.fetchRenderProp = function (options) {\n      return new Promise(function (resolve) {\n        // We wrap this in a setTimeout so as to avoid calls to `setState`\n        // in render, which React does not allow.\n        //\n        // tl;dr, the following code should never cause a React warning or error:\n        //\n        // `<Fetch children={({ doFetch }) => doFetch()} />\n        setTimeout(function () {\n          _this.fetchData(options, true, resolve);\n        });\n      });\n    };\n\n    _this.getRequestKey = function (options) {\n      // A request key in the options gets top priority\n      if (options && options.requestKey) {\n        return options.requestKey;\n      }\n\n      // Otherwise, if we have no request key, but we do have options, then we\n      // recompute the request key based on these options.\n      // Note that if the URL, body, or method have not changed, then the request\n      // key should match the previous request key if it was computed.\n      // If you passed in a custom request key as a prop, then you will also\n      // need to pass in a custom key when you call `doFetch()`!\n      else if (options) {\n          var _Object$assign = Object.assign({}, _this.props, options),\n              url = _Object$assign.url,\n              method = _Object$assign.method,\n              body = _Object$assign.body;\n\n          return getRequestKey({\n            url: url,\n            body: body,\n            method: method.toUpperCase()\n          });\n        }\n\n        // Next in line is the the request key from props.\n        else if (_this.props.requestKey) {\n            return _this.props.requestKey;\n          }\n\n          // Lastly, we compute the request key from the props.\n          else {\n              var _this$props4 = _this.props,\n                  _url = _this$props4.url,\n                  _method = _this$props4.method,\n                  _body = _this$props4.body;\n\n\n              return getRequestKey({\n                url: _url,\n                body: _body,\n                method: _method.toUpperCase()\n              });\n            }\n    };\n\n    _this.fetchData = function (options, ignoreCache, resolve) {\n      // These are the things that we do not allow a user to configure in\n      // `options` when calling `doFetch()`. Perhaps we should, however.\n      var _this$props5 = _this.props,\n          requestName = _this$props5.requestName,\n          dedupe = _this$props5.dedupe,\n          beforeFetch = _this$props5.beforeFetch;\n\n\n      _this.cancelExistingRequest('New fetch initiated');\n\n      var requestKey = _this.getRequestKey(options);\n      var requestOptions = Object.assign({}, _this.props, options);\n\n      _this._currentRequestKey = requestKey;\n\n      var url = requestOptions.url,\n          body = requestOptions.body,\n          credentials = requestOptions.credentials,\n          headers = requestOptions.headers,\n          method = requestOptions.method,\n          responseType = requestOptions.responseType,\n          mode = requestOptions.mode,\n          cache = requestOptions.cache,\n          redirect = requestOptions.redirect,\n          referrer = requestOptions.referrer,\n          referrerPolicy = requestOptions.referrerPolicy,\n          integrity = requestOptions.integrity,\n          keepalive = requestOptions.keepalive,\n          signal = requestOptions.signal;\n\n\n      var uppercaseMethod = method.toUpperCase();\n      var shouldCacheResponse = _this.shouldCacheResponse();\n\n      var init = {\n        body: body,\n        credentials: credentials,\n        headers: headers,\n        method: uppercaseMethod,\n        mode: mode,\n        cache: cache,\n        redirect: redirect,\n        referrer: referrer,\n        referrerPolicy: referrerPolicy,\n        integrity: integrity,\n        keepalive: keepalive,\n        signal: signal\n      };\n\n      var responseReceivedInfo = {\n        url: url,\n        init: init,\n        requestKey: requestKey,\n        responseType: responseType\n      };\n\n      // This is necessary because `options` may have overridden the props.\n      // If the request config changes, we need to be able to accurately\n      // cancel the in-flight request.\n      _this.responseReceivedInfo = responseReceivedInfo;\n\n      var fetchPolicy = _this.getFetchPolicy();\n\n      var cachedResponse = void 0;\n      if (fetchPolicy !== 'network-only' && !ignoreCache) {\n        cachedResponse = responseCache[requestKey];\n\n        if (cachedResponse) {\n          _this.onResponseReceived(_extends({}, responseReceivedInfo, {\n            response: cachedResponse,\n            hittingNetwork: false,\n            stillFetching: fetchPolicy === 'cache-and-network'\n          }));\n\n          if (fetchPolicy === 'cache-first' || fetchPolicy === 'cache-only') {\n            return Promise.resolve(cachedResponse);\n          }\n        } else if (fetchPolicy === 'cache-only') {\n          var cacheError = new Error('Response for \"' + requestName + '\" not found in cache.');\n          _this.onResponseReceived(_extends({}, responseReceivedInfo, {\n            error: cacheError,\n            hittingNetwork: false\n          }));\n          return Promise.resolve(cacheError);\n        }\n      }\n\n      _this.setState({\n        requestKey: requestKey,\n        url: url,\n        error: null,\n        failed: false,\n        fetching: true\n      });\n      var hittingNetwork = !isRequestInFlight(requestKey) || !dedupe;\n\n      if (hittingNetwork) {\n        beforeFetch({\n          url: url,\n          init: init,\n          requestKey: requestKey\n        });\n      }\n      return fetchDedupe(url, init, { requestKey: requestKey, responseType: responseType, dedupe: dedupe }).then(function (res) {\n        if (shouldCacheResponse) {\n          responseCache[requestKey] = res;\n        }\n\n        if (_this._currentRequestKey === requestKey) {\n          _this.onResponseReceived(_extends({}, responseReceivedInfo, {\n            response: res,\n            hittingNetwork: hittingNetwork,\n            resolve: resolve\n          }));\n        }\n\n        return res;\n      }, function (error) {\n        if (_this._currentRequestKey === requestKey) {\n          _this.onResponseReceived(_extends({}, responseReceivedInfo, {\n            error: error,\n            cachedResponse: cachedResponse,\n            hittingNetwork: hittingNetwork,\n            resolve: resolve\n          }));\n        }\n\n        return error;\n      });\n    };\n\n    _this.onResponseReceived = function (info) {\n      var _info$error = info.error,\n          error = _info$error === undefined ? null : _info$error,\n          _info$response = info.response,\n          response = _info$response === undefined ? null : _info$response,\n          hittingNetwork = info.hittingNetwork,\n          url = info.url,\n          init = info.init,\n          requestKey = info.requestKey,\n          cachedResponse = info.cachedResponse,\n          _info$stillFetching = info.stillFetching,\n          stillFetching = _info$stillFetching === undefined ? false : _info$stillFetching,\n          resolve = info.resolve;\n\n\n      _this.responseReceivedInfo = null;\n\n      if (!stillFetching) {\n        _this._currentRequestKey = null;\n      }\n\n      var data = void 0;\n      // If our response succeeded, then we use that data.\n      if (response && response.data) {\n        data = response.data;\n      } else if (cachedResponse && cachedResponse.data) {\n        // This happens when the request failed, but we have cache-and-network\n        // specified. Although we pass along the failed response, we continue to\n        // pass in the cached data.\n        data = cachedResponse.data;\n      }\n\n      data = data ? _this.props.transformData(data) : null;\n\n      // If we already have some data in state on error, then we continue to\n      // pass that data down. This prevents the data from being wiped when a\n      // request fails, which is generally not what people want.\n      // For more, see: GitHub Issue #154\n      if (error && _this.state.data) {\n        data = _this.state.data;\n      }\n\n      var afterFetchInfo = {\n        url: url,\n        init: init,\n        requestKey: requestKey,\n        error: error,\n        failed: Boolean(error || response && !response.ok),\n        response: response,\n        data: data,\n        didUnmount: Boolean(_this.willUnmount)\n      };\n\n      if (typeof resolve === 'function') {\n        resolve(afterFetchInfo);\n      }\n\n      if (hittingNetwork) {\n        _this.props.afterFetch(afterFetchInfo);\n      }\n\n      if (_this.willUnmount) {\n        return;\n      }\n\n      _this.setState({\n        url: url,\n        data: data,\n        error: error,\n        response: response,\n        fetching: stillFetching,\n        requestKey: requestKey\n      }, function () {\n        return _this.props.onResponse(error, response);\n      });\n    };\n\n    _this.state = {\n      requestKey: props.requestKey || getRequestKey(_extends({}, props, {\n        method: props.method.toUpperCase()\n      })),\n      requestName: props.requestName,\n      fetching: false,\n      response: null,\n      data: null,\n      error: null,\n      url: props.url\n    };\n    return _this;\n  }\n\n  // We default to being lazy for \"write\" requests,\n  // such as POST, PATCH, DELETE, and so on.\n\n\n  _createClass(Fetch, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      if (!this.isLazy()) {\n        this.fetchData();\n      }\n    }\n\n    // Because we use `componentDidUpdate` to determine if we should fetch\n    // again, there will be at least one render when you receive your new\n    // fetch options, such as a new URL, but the fetch has not begun yet.\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps) {\n      var currentRequestKey = this.props.requestKey || getRequestKey(_extends({}, this.props, {\n        method: this.props.method.toUpperCase()\n      }));\n      var prevRequestKey = prevProps.requestKey || getRequestKey(_extends({}, prevProps, {\n        method: prevProps.method.toUpperCase()\n      }));\n\n      if (currentRequestKey !== prevRequestKey && !this.isLazy()) {\n        this.fetchData({\n          requestKey: currentRequestKey\n        });\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this.willUnmount = true;\n      this.cancelExistingRequest('Component unmounted');\n    }\n\n    // When a request is already in flight, and a new one is\n    // configured, then we need to \"cancel\" the previous one.\n\n\n    // When a subsequent request is made, it is important that the correct\n    // request key is used. This method computes the right key based on the\n    // options and props.\n\n  }]);\n\n  return Fetch;\n}(React.Component);\n\nvar globalObj = typeof self !== 'undefined' ? self : this;\nvar AbortSignalCtr = globalObj !== undefined ? globalObj.AbortSignal : function () {};\n\nFetch.propTypes = {\n  children: PropTypes.func,\n  requestName: PropTypes.string,\n  fetchPolicy: PropTypes.oneOf(['cache-first', 'cache-and-network', 'network-only', 'cache-only']),\n  onResponse: PropTypes.func,\n  beforeFetch: PropTypes.func,\n  afterFetch: PropTypes.func,\n  responseType: PropTypes.oneOfType([PropTypes.func, PropTypes.oneOf(['json', 'text', 'blob', 'arrayBuffer', 'formData'])]),\n  transformData: PropTypes.func,\n  lazy: PropTypes.bool,\n  dedupe: PropTypes.bool,\n  requestKey: PropTypes.string,\n\n  url: PropTypes.string.isRequired,\n  body: PropTypes.any,\n  credentials: PropTypes.oneOf(['omit', 'same-origin', 'include']),\n  headers: PropTypes.object,\n  method: PropTypes.oneOf(['get', 'post', 'put', 'patch', 'delete', 'options', 'head', 'GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS', 'HEAD']),\n  mode: PropTypes.oneOf(['same-origin', 'cors', 'no-cors', 'navigate', 'websocket']),\n  cache: PropTypes.oneOf(['default', 'no-store', 'reload', 'no-cache', 'force-cache', 'only-if-cached']),\n  redirect: PropTypes.oneOf(['manual', 'follow', 'error']),\n  referrer: PropTypes.string,\n  referrerPolicy: PropTypes.oneOf(['no-referrer', 'no-referrer-when-downgrade', 'origin', 'origin-when-cross-origin', 'unsafe-url', '']),\n  integrity: PropTypes.string,\n  keepalive: PropTypes.bool,\n  signal: PropTypes.instanceOf(AbortSignalCtr)\n};\n\nFetch.defaultProps = {\n  requestName: 'anonymousRequest',\n  onResponse: function onResponse() {},\n  beforeFetch: function beforeFetch() {},\n  afterFetch: function afterFetch() {},\n  transformData: function transformData(data) {\n    return data;\n  },\n  dedupe: true,\n\n  method: 'get',\n  referrerPolicy: '',\n  integrity: '',\n  referrer: 'about:client'\n};"]},"metadata":{},"sourceType":"module"}