{"ast":null,"code":"// This is a cache of in-flight requests. Each request key maps to an\n// array of Promises. When the request resolves, each promise in the\n// array is pushed to.\nvar requests = {};\nexport function getRequestKey() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$url = _ref.url,\n      url = _ref$url === undefined ? '' : _ref$url,\n      _ref$method = _ref.method,\n      method = _ref$method === undefined ? '' : _ref$method,\n      _ref$responseType = _ref.responseType,\n      responseType = _ref$responseType === undefined ? '' : _ref$responseType,\n      _ref$body = _ref.body,\n      body = _ref$body === undefined ? '' : _ref$body;\n\n  return [url, method.toUpperCase(), responseType, body].join('||');\n} // Returns `true` if a request with `requestKey` is in flight,\n// and `false` otherwise.\n\nexport function isRequestInFlight(requestKey) {\n  return Boolean(requests[requestKey]);\n}\nexport function clearRequestCache() {\n  requests = {};\n} // This loops through all of the handlers for the request and either\n// resolves or rejects them.\n\nfunction resolveRequest(_ref2) {\n  var requestKey = _ref2.requestKey,\n      res = _ref2.res,\n      err = _ref2.err;\n  var handlers = requests[requestKey] || [];\n  handlers.forEach(function (handler) {\n    if (res) {\n      handler.resolve(res);\n    } else {\n      handler.reject(err);\n    }\n  }); // This list of handlers has been, well, handled. So we\n  // clear the handlers for the next request.\n\n  requests[requestKey] = null;\n}\n\nexport function fetchDedupe(input) {\n  var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var dedupeOptions = arguments[2];\n  var opts = void 0,\n      initToUse = void 0;\n\n  if (dedupeOptions) {\n    opts = dedupeOptions;\n    initToUse = init;\n  } else if (init.responseType) {\n    opts = init;\n    initToUse = {};\n  } else {\n    opts = {};\n    initToUse = init;\n  }\n\n  var _opts = opts,\n      requestKey = _opts.requestKey,\n      _opts$responseType = _opts.responseType,\n      responseType = _opts$responseType === undefined ? '' : _opts$responseType,\n      _opts$dedupe = _opts.dedupe,\n      dedupe = _opts$dedupe === undefined ? true : _opts$dedupe; // Build the default request key if one is not passed\n\n  var requestKeyToUse = requestKey || getRequestKey({\n    // If `input` is a request, then we use that URL\n    url: input.url || input,\n    // We prefer values from `init` over request objects. With `fetch()`, init\n    // takes priority over a passed-in request\n    method: initToUse.method || input.method || '',\n    body: initToUse.body || input.body || ''\n  });\n  var proxyReq = void 0;\n\n  if (dedupe) {\n    if (!requests[requestKeyToUse]) {\n      requests[requestKeyToUse] = [];\n    }\n\n    var handlers = requests[requestKeyToUse];\n    var requestInFlight = Boolean(handlers.length);\n    var requestHandler = {};\n    proxyReq = new Promise(function (resolve, reject) {\n      requestHandler.resolve = resolve;\n      requestHandler.reject = reject;\n    });\n    handlers.push(requestHandler);\n\n    if (requestInFlight) {\n      return proxyReq;\n    }\n  }\n\n  var request = fetch(input, initToUse).then(function (res) {\n    var responseTypeToUse = void 0;\n\n    if (responseType instanceof Function) {\n      responseTypeToUse = responseType(res);\n    } else if (responseType) {\n      responseTypeToUse = responseType;\n    } else if (res.status === 204) {\n      responseTypeToUse = 'text';\n    } else {\n      responseTypeToUse = 'json';\n    } // The response body is a ReadableStream. ReadableStreams can only be read a single\n    // time, so we must handle that in a central location, here, before resolving\n    // the fetch.\n\n\n    return res[responseTypeToUse]().then(function (data) {\n      res.data = data;\n\n      if (dedupe) {\n        resolveRequest({\n          requestKey: requestKeyToUse,\n          res: res\n        });\n      } else {\n        return res;\n      }\n    }, function () {\n      res.data = null;\n\n      if (dedupe) {\n        resolveRequest({\n          requestKey: requestKeyToUse,\n          res: res\n        });\n      } else {\n        return res;\n      }\n    });\n  }, function (err) {\n    if (dedupe) {\n      resolveRequest({\n        requestKey: requestKeyToUse,\n        err: err\n      });\n    } else {\n      return Promise.reject(err);\n    }\n  });\n\n  if (dedupe) {\n    return proxyReq;\n  } else {\n    return request;\n  }\n}","map":{"version":3,"sources":["/home/andrey/Documents/React/8/node_modules/fetch-dedupe/es/index.js"],"names":["requests","getRequestKey","_ref","arguments","length","undefined","_ref$url","url","_ref$method","method","_ref$responseType","responseType","_ref$body","body","toUpperCase","join","isRequestInFlight","requestKey","Boolean","clearRequestCache","resolveRequest","_ref2","res","err","handlers","forEach","handler","resolve","reject","fetchDedupe","input","init","dedupeOptions","opts","initToUse","_opts","_opts$responseType","_opts$dedupe","dedupe","requestKeyToUse","proxyReq","requestInFlight","requestHandler","Promise","push","request","fetch","then","responseTypeToUse","Function","status","data"],"mappings":"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","sourcesContent":["// This is a cache of in-flight requests. Each request key maps to an\n// array of Promises. When the request resolves, each promise in the\n// array is pushed to.\nvar requests = {};\n\nexport function getRequestKey() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$url = _ref.url,\n      url = _ref$url === undefined ? '' : _ref$url,\n      _ref$method = _ref.method,\n      method = _ref$method === undefined ? '' : _ref$method,\n      _ref$responseType = _ref.responseType,\n      responseType = _ref$responseType === undefined ? '' : _ref$responseType,\n      _ref$body = _ref.body,\n      body = _ref$body === undefined ? '' : _ref$body;\n\n  return [url, method.toUpperCase(), responseType, body].join('||');\n}\n\n// Returns `true` if a request with `requestKey` is in flight,\n// and `false` otherwise.\nexport function isRequestInFlight(requestKey) {\n  return Boolean(requests[requestKey]);\n}\n\nexport function clearRequestCache() {\n  requests = {};\n}\n\n// This loops through all of the handlers for the request and either\n// resolves or rejects them.\nfunction resolveRequest(_ref2) {\n  var requestKey = _ref2.requestKey,\n      res = _ref2.res,\n      err = _ref2.err;\n\n  var handlers = requests[requestKey] || [];\n\n  handlers.forEach(function (handler) {\n    if (res) {\n      handler.resolve(res);\n    } else {\n      handler.reject(err);\n    }\n  });\n\n  // This list of handlers has been, well, handled. So we\n  // clear the handlers for the next request.\n  requests[requestKey] = null;\n}\n\nexport function fetchDedupe(input) {\n  var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var dedupeOptions = arguments[2];\n\n  var opts = void 0,\n      initToUse = void 0;\n  if (dedupeOptions) {\n    opts = dedupeOptions;\n    initToUse = init;\n  } else if (init.responseType) {\n    opts = init;\n    initToUse = {};\n  } else {\n    opts = {};\n    initToUse = init;\n  }\n\n  var _opts = opts,\n      requestKey = _opts.requestKey,\n      _opts$responseType = _opts.responseType,\n      responseType = _opts$responseType === undefined ? '' : _opts$responseType,\n      _opts$dedupe = _opts.dedupe,\n      dedupe = _opts$dedupe === undefined ? true : _opts$dedupe;\n\n  // Build the default request key if one is not passed\n\n  var requestKeyToUse = requestKey || getRequestKey({\n    // If `input` is a request, then we use that URL\n    url: input.url || input,\n    // We prefer values from `init` over request objects. With `fetch()`, init\n    // takes priority over a passed-in request\n    method: initToUse.method || input.method || '',\n    body: initToUse.body || input.body || ''\n  });\n\n  var proxyReq = void 0;\n  if (dedupe) {\n    if (!requests[requestKeyToUse]) {\n      requests[requestKeyToUse] = [];\n    }\n\n    var handlers = requests[requestKeyToUse];\n    var requestInFlight = Boolean(handlers.length);\n    var requestHandler = {};\n    proxyReq = new Promise(function (resolve, reject) {\n      requestHandler.resolve = resolve;\n      requestHandler.reject = reject;\n    });\n\n    handlers.push(requestHandler);\n\n    if (requestInFlight) {\n      return proxyReq;\n    }\n  }\n\n  var request = fetch(input, initToUse).then(function (res) {\n    var responseTypeToUse = void 0;\n    if (responseType instanceof Function) {\n      responseTypeToUse = responseType(res);\n    } else if (responseType) {\n      responseTypeToUse = responseType;\n    } else if (res.status === 204) {\n      responseTypeToUse = 'text';\n    } else {\n      responseTypeToUse = 'json';\n    }\n    // The response body is a ReadableStream. ReadableStreams can only be read a single\n    // time, so we must handle that in a central location, here, before resolving\n    // the fetch.\n    return res[responseTypeToUse]().then(function (data) {\n      res.data = data;\n\n      if (dedupe) {\n        resolveRequest({ requestKey: requestKeyToUse, res: res });\n      } else {\n        return res;\n      }\n    }, function () {\n      res.data = null;\n\n      if (dedupe) {\n        resolveRequest({ requestKey: requestKeyToUse, res: res });\n      } else {\n        return res;\n      }\n    });\n  }, function (err) {\n    if (dedupe) {\n      resolveRequest({ requestKey: requestKeyToUse, err: err });\n    } else {\n      return Promise.reject(err);\n    }\n  });\n\n  if (dedupe) {\n    return proxyReq;\n  } else {\n    return request;\n  }\n}"]},"metadata":{},"sourceType":"module"}